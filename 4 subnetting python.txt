gedit filename.py 
python3 filename.py
//////////////////////////

import socket
# Imports the socket module which provides access to networking functions,
# including DNS name resolution functions used in this script.

def get_ip_from_hostname():
    hostname = input("Enter the Hostname (e.g., www.google.com): ")
    # Prompts the user to enter a domain name (hostname) and stores it in the variable `hostname`.

    try:
        ip = socket.gethostbyname(hostname)
        # Calls socket.gethostbyname(hostname) to resolve the given hostname to an IPv4 address string.
        # If resolution succeeds, the function returns a string like "142.250.183.196".

        print(f"IP address of {hostname} is: {ip}")
        # Prints the resolved IP address to the console in a readable format.

    except socket.gaierror:
        print("Invalid Hostname or unable to resolve!")
        # Catches socket.gaierror which occurs if the hostname cannot be resolved
        # (bad name, no network, DNS failure). Prints an error message.

def get_hostname_from_ip():
    ip_address = input("Enter the IP Address (e.g., 142.250.183.196): ")
    # Prompts the user to enter an IP address (string) and stores it in `ip_address`.

    try:
        host = socket.gethostbyaddr(ip_address)
        # Calls socket.gethostbyaddr(ip_address) to perform a reverse DNS lookup.
        # On success it returns a tuple: (primary_hostname, aliaslist, ipaddrlist).

        print(f"Hostname for IP {ip_address} is: {host[0]}")
        # Prints the primary hostname (first element of the returned tuple).
        # host[0] is typically the canonical name for the IP.

    except socket.herror:
        print("Invalid IP Address or unable to resolve!")
        # Catches socket.herror which occurs if the reverse lookup fails
        # (no PTR record, invalid IP format, or network/DNS issues). Prints an error.

def main():
    while True:
        print("\n===== DNS Lookup Menu =====")
        print("1. Find IP Address from Hostname")
        print("2. Find Hostname from IP Address")
        print("3. Exit")
        # Prints a simple text menu each loop iteration so the user can choose an option.

        choice = input("Enter your choice (1-3): ")
        # Reads the user's choice as a string.

        if choice == "1":
            get_ip_from_hostname()
            # If user entered "1", call the function to resolve hostname → IP.

        elif choice == "2":
            get_hostname_from_ip()
            # If user entered "2", call the function to resolve IP → hostname.

        elif choice == "3":
            print("Exiting... Goodbye!")
            break
            # If user entered "3", print exit message and break out of the loop to end the program.

        else:
            print("Invalid choice! Please enter 1, 2, or 3.")
            # For any other input, inform the user and re-show the menu.

if __name__ == "__main__":
    main()
    # Standard Python idiom: when the script is run directly (not imported), call main().
    # This starts the interactive menu loop and lets the user perform DNS lookups.



/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


Assignment No: 4  
Title: Write a program to demonstrate Subnetting and find subnet masks.

• Objective:
  – To learn different network address classes (A, B, C, D, E).  
  – To understand the concept and purpose of subnetting.  
  – To calculate subnet masks and identify network, host, and broadcast addresses.

• Aim:
  – The aim of this practical is to divide a large network into smaller sub-networks (subnets) to efficiently utilize IP addresses and improve network performance.

• Tools Used:
  – Cisco Packet Tracer (for simulation)  
  – Calculator or Subnetting Table (for manual subnet mask calculation)

• Concept Description:
  1. **Subnetting:**  
     – Subnetting is the process of dividing one large network into multiple smaller logical networks (subnets).  
     – Each subnet acts as an independent network that helps reduce broadcast traffic and improves manageability.  
     – It is performed at Layer 3 (Network Layer) using the IP address.

  2. **IPv4 Addressing:**
     – IPv4 addresses are 32-bit numbers written in dotted-decimal format (e.g., 192.168.1.10).  
     – Each IP address consists of two parts:
       • Network portion – identifies the network.  
       • Host portion – identifies a specific device (host) within that network.  
     – Example:  
       IP Address: 192.168.1.10  
       Subnet Mask: 255.255.255.0  
       → Network part: 192.168.1  
       → Host part: 10

  3. **Subnet Mask:**
     – A 32-bit value used to differentiate the network portion and host portion of an IP address.  
     – Binary 1s in the subnet mask represent the network part, while 0s represent the host part.  
     – Example:  
       IP Address: 192.168.1.10  
       Subnet Mask: 255.255.255.0  
       Binary Form:  
       IP:   11000000.10101000.00000001.00001010  
       Mask: 11111111.11111111.11111111.00000000  

  4. **IP Address Classes:**
     | Class | Range (First Octet) | Default Subnet Mask | Network Bits | Host Bits | Total Hosts | Valid Hosts |
     |--------|--------------------|----------------------|---------------|------------|--------------|--------------|
     | A | 1–126 | 255.0.0.0 | 8 | 24 | 16,777,216 | 16,777,214 |
     | B | 128–191 | 255.255.0.0 | 16 | 16 | 65,536 | 65,534 |
     | C | 192–223 | 255.255.255.0 | 24 | 8 | 256 | 254 |

  5. **Important Terms:**
     – **Network ID:** The first address of a subnet, used to identify that subnet.  
     – **Broadcast ID:** The last address in a subnet, used to communicate with all hosts in that subnet.  
     – **Block Size:** The total number of addresses in a subnet (including network and broadcast).  
     – **Host Addresses:** All addresses between the network and broadcast addresses; assignable to devices.

  6. **Subnetting Example:**
     Suppose you have a Class C network:  
     IP Address: 192.168.10.0/24  
     Default Mask: 255.255.255.0  
     → Borrow 2 bits from the host portion.  
     → New Subnet Mask: 255.255.255.192 (/26)  
     → Each subnet has 64 addresses (62 usable hosts).  
     → Subnets created:  
       1. 192.168.10.0 – 192.168.10.63  
       2. 192.168.10.64 – 192.168.10.127  
       3. 192.168.10.128 – 192.168.10.191  
       4. 192.168.10.192 – 192.168.10.255

• Why We Perform This Practical:
  – To understand how IP addresses are divided into networks and hosts.  
  – To efficiently utilize IP address space and reduce wastage.  
  – To apply subnetting in real-life scenarios for designing scalable networks.

• Procedure Summary:
  1. Choose an IP address and identify its class.  
  2. Decide the number of subnets required.  
  3. Borrow bits from the host portion to create new subnetworks.  
  4. Calculate the new subnet mask and block size.  
  5. Identify the network ID, broadcast ID, and valid host range for each subnet.  
  6. Verify configurations in Cisco Packet Tracer or manually.

• Advantages of Subnetting:
  – Reduces network congestion and broadcast traffic.  
  – Enhances network security and management.  
  – Enables efficient utilization of IP address ranges.  
  – Simplifies troubleshooting and maintenance.

• Output:
  – Successfully calculated subnet masks and created multiple subnets from a single network range.  
  – Verified correct assignment of network, broadcast, and host addresses.

• Concept Used:
  – IPv4 Addressing and Classes  
  – Binary Conversion of IP and Subnet Masks  
  – Bit Borrowing and CIDR Notation (/n)  
  – Network and Broadcast Address Calculation

• Outcome:
  – Students learned to perform subnetting calculations.  
  – Understood the use of subnet masks in distinguishing network and host portions.

• Conclusion:
  – Subnetting allows efficient management of IP addresses and network segmentation.  
  – The practical demonstrated how to calculate subnet masks and divide a large network into smaller, manageable subnets.


