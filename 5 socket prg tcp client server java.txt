gedit HelloWorld.java
javac HelloWorld.java
java HelloWorld

////////////////////////////////////////////////////////////////////////////////////


Steps to Run TCP Client & Server in Ubuntu (Two Terminals)

STEP 1: Create the Java files
Open Terminal 1 (for server)

Go to your folder (Desktop or Documents):
cd Desktop
Create server file:
gedit TCPServer.java
Paste your TCPServer code ‚Üí Save ‚Üí Close.
Open Terminal 2 (for client)
cd Desktop
Create client file:
gedit TCPClient.java
Paste your TCPClient code ‚Üí Save ‚Üí Close.
STEP 2: Compile Both Files
In Terminal 1 (server terminal):
javac TCPServer.java
In Terminal 2 (client terminal):
javac TCPClient.java
If no errors ‚Äî perfect.
STEP 3: Run Server First
In Terminal 1:
java TCPServer
You should see:

Server started. Waiting for client...
This means server is listening on port 5000.

STEP 4: Run Client
In Terminal 2:
java TCPClient
You should see:
Connected to server.
Message from server: Hello from Server!
Server terminal will display:
Client connected!
Message sent and server closed.

If You Get Error Like:
‚ÄúPort 5000 already in use‚Äù

OR

Client: Connection refused

OR

Server not starting

Then the correction is done on the SERVER side, not the client.

‚úÖ WHY?
‚úîÔ∏è The server is the one that OPENS the port (5000):
ServerSocket server = new ServerSocket(5000);


If port 5000 is already used by another process,
the server cannot start, so the client will fail automatically.

The client only connects to a port.

If the server is not running, the client cannot connect.

What You Should Fix (on Server Side)
Fix 1 ‚Üí Change the port number in the server

Example:
ServerSocket server = new ServerSocket(6000);
Then also update client:
Socket socket = new Socket("localhost", 6000);


Server and client port numbers must match.
Fix 2 ‚Üí Free the port (if you want to keep same port 5000)
Step 1: Check who is using port 5000
sudo lsof -i :5000
It will show something like:
java   2314   user   5000
Step 2: Kill that process
kill -9 <PID>
Example:
kill -9 2314


Now run your server again:
java TCPServer



/////////////////////////////////////////////////////////////////////////////////////////////////////




Running your TCP Client‚ÄìServer Java program on two different PCs is very easy once you understand how IP addresses work.
Here is the complete, step-by-step guide üëá

‚úÖ REQUIREMENTS

‚úî Both PCs must be connected to the same network (WiFi or LAN)
‚úî Java must be installed on both systems
‚úî Firewall must allow Java programs to use ports

üñ•Ô∏è Assume:

PC 1 = Server

PC 2 = Client

Server is listening on port 5000

STEP 1Ô∏è‚É£ ‚Äî Find Server PC‚Äôs IP Address

‚ö° On PC 1 (Server PC) open terminal and type:

For Ubuntu:
ifconfig


or

ip addr show


Look for:

inet 192.168.x.x


Example server IP:

192.168.1.20


üëâ This IP is the address the client will connect to.

STEP 2Ô∏è‚É£ ‚Äî Update Client Code

In your client code, replace "localhost" with the server PC‚Äôs IP:

Socket socket = new Socket("192.168.1.20", 5000);


‚ö†Ô∏è localhost works only when server and client are on the same machine.
On two PCs, you MUST use server‚Äôs LAN IP.

STEP 3Ô∏è‚É£ ‚Äî Start Server on PC 1

On PC 1:

javac TCPServer.java
java TCPServer


Output should be:

Server started. Waiting for client...


The server will now listen for connections on:

192.168.1.20:5000

(or whatever your real IP is)

STEP 4Ô∏è‚É£ ‚Äî Start Client on PC 2

On PC 2:

javac TCPClient.java
java TCPClient


If connection succeeds, you will see:

Connected to server.
Message from server: Hello from Server!


Server terminal shows:

Client connected!
Message sent and server closed.

üõë If It Does NOT Work ‚Äî Fix These Issues
‚ùå Problem 1: Firewall Blocking Port

On Ubuntu server, allow port 5000:

sudo ufw allow 5000

‚ùå Problem 2: Wrong IP Address

Make sure server IP is correct:

ip addr


Use inet not 127.0.0.1
NEVER use localhost for two-PC communication.

‚ùå Problem 3: Client & Server on Different Networks

They MUST be in same network:
Example:

Server: 192.168.1.20

Client: 192.168.1.35
‚Üí Same network ‚úîÔ∏è

If:

Server: 192.168.1.20

Client: 10.0.4.12
‚Üí Different networks ‚ùå

‚ùå Problem 4: Port Already in Use

Check:

sudo lsof -i :5000


Kill if needed:

kill -9 <PID>

üìå Summary (Very Important)
PC	Role	Command	Note
PC 1	Server	java TCPServer	Must run first
PC 2	Client	java TCPClient	Must use server IP

Client line must be:

Socket socket = new Socket("<server ip>", 5000);

üéâ Done! Your program now works over two different computers.

///////////////////////////////////////////////////////////////////////////////////

===============================
TCP CLIENT ‚Äì LINE-BY-LINE EXPLANATION (JAVA COMMENTS)
===============================

import java.io.InputStream;
import java.net.Socket;
// Import InputStream for receiving data.
// Import Socket for connecting to the server.

public class TCPClient {
// Defines the TCPClient class.

    public static void main(String[] args) {
    // Program execution starts here.

        try {
        // try block to catch and handle any networking errors.

            Socket socket = new Socket("localhost", 5000);
            // Creates a TCP socket and connects to server at localhost on port 5000.
            // If server is not running, this will throw an exception.

            System.out.println("Connected to server.");
            // Confirms connection success.

            InputStream in = socket.getInputStream();
            // Obtains the input stream that receives data from server.

            byte[] buffer = new byte[1024];
            // Allocates a buffer to store incoming bytes.

            int bytesRead = in.read(buffer);
            // Reads data sent from the server into the buffer.
            // The function returns number of bytes read.
            // This method waits until server sends data.

            String message = new String(buffer, 0, bytesRead);
            // Converts the received bytes into a readable string.

            System.out.println("Message from server: " + message);
            // Prints the message received from the server.

            socket.close();
            // Closes the socket and disconnects from server.

        } catch (Exception e) {
            e.printStackTrace();
            // Prints any exception or error that occurs.
        }
    }
}


===============================
TCP SERVER ‚Äì LINE-BY-LINE EXPLANATION (JAVA COMMENTS)
===============================

import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;
// ServerSocket is used for listening for client connections.
// Socket is for communicating once the client is connected.
// OutputStream is used for sending data to the client.

public class TCPServer {
// Defines the TCPServer class.

    public static void main(String[] args) {
    // Main method begins.

        try {
        // try block to catch network or IO exceptions.

            ServerSocket server = new ServerSocket(5000);
            // Creates a server socket that listens on port 5000.

            System.out.println("Server started. Waiting for client...");
            // Indicates server is ready but waiting for a client.

            Socket clientSocket = server.accept();
            // Waits until a client connects.
            // When connection arrives, accept() returns a Socket object.

            System.out.println("Client connected!");
            // Confirms client has successfully connected.

            OutputStream out = clientSocket.getOutputStream();
            // Gets the output stream used to send data to the client.

            String message = "Hello from Server!";
            // Message that server wants to send to the client.

            out.write(message.getBytes());
            // Converts string to bytes and sends it to client.

            out.flush();
            // Ensures all bytes are sent without delay.

            clientSocket.close();
            // Closes the client connection after sending the message.

            server.close();
            // Shuts down the server socket (stops listening on port 5000).

            System.out.println("Message sent and server closed.");
            // Final confirmation message.

        } catch (Exception e) {
            e.printStackTrace();
            // Prints the detailed error message if anything goes wrong.
        }
    }
}




//////////////////////////////////////////////////////////////////////////////////////




Assignment No: 5
Title: Socket Programming using C/C++/Java
‚Ä¢ TCP Client, TCP Server
‚Ä¢ UDP Client, UDP Server

------------------------------------------------------
1. OBJECTIVE:
------------------------------------------------------
‚Ä¢ To learn and implement socket programming in computer networks.
‚Ä¢ To understand client-server communication models.
‚Ä¢ To learn and differentiate between TCP (connection-oriented) and UDP (connectionless) communication.

------------------------------------------------------
2. WHY WE PERFORM THIS PRACTICAL:
------------------------------------------------------
‚Ä¢ To gain hands-on experience with real-time network communication.
‚Ä¢ To learn how client and server programs exchange data over TCP and UDP.
‚Ä¢ To understand how sockets act as endpoints for sending and receiving data across networks.
‚Ä¢ To prepare students for real-world applications like chat systems, file transfers, and web communication.

------------------------------------------------------
3. CONCEPT / THEORY:
------------------------------------------------------
A. Socket Programming:
‚Ä¢ A socket is an endpoint for communication between two machines.
‚Ä¢ It allows a process on one computer to communicate with a process on another over a network.
‚Ä¢ Socket programming uses a set of functions to establish connections, send, and receive data.

B. Types of Sockets:
‚Ä¢ Stream Sockets (SOCK_STREAM): Use TCP; reliable, connection-oriented.
‚Ä¢ Datagram Sockets (SOCK_DGRAM): Use UDP; unreliable, connectionless.

------------------------------------------------------
4. USER DATAGRAM PROTOCOL (UDP):
------------------------------------------------------
‚Ä¢ UDP is a simple transport-layer protocol that sends data as independent packets called datagrams.
‚Ä¢ It is connectionless ‚Äî no need to establish or terminate a connection.
‚Ä¢ UDP does not guarantee delivery, ordering, or duplication protection.
‚Ä¢ It is used for real-time applications like DNS, video streaming, VoIP, and online gaming.

UDP SOCKET API Functions:
‚Ä¢ socket(): Create a socket.
‚Ä¢ bind(): Bind socket to a local address and port.
‚Ä¢ sendto(): Send data to a specific destination.
‚Ä¢ recvfrom(): Receive data from a sender.

UDP Client Steps:
1. Create a socket using socket().
2. Use sendto() to send data.
3. Use recvfrom() to receive data.
4. Close the socket.

UDP Server Steps:
1. Create a socket using socket().
2. Bind it to an address and port using bind().
3. Wait for data using recvfrom().
4. Send response using sendto().
5. Close the socket.

------------------------------------------------------
5. TRANSMISSION CONTROL PROTOCOL (TCP):
------------------------------------------------------
‚Ä¢ TCP is a connection-oriented protocol ‚Äî a reliable, stream-based communication.
‚Ä¢ It ensures data is received accurately and in the correct order.
‚Ä¢ Uses a 3-way handshake to establish a connection.
‚Ä¢ Provides error checking, flow control, and congestion control.

TCP SOCKET API Functions:
‚Ä¢ socket(): Create a socket for communication.
‚Ä¢ bind(): Bind socket to a local address and port.
‚Ä¢ listen(): Set up the server to wait for client connections.
‚Ä¢ accept(): Accept a connection from a client.
‚Ä¢ connect(): Used by the client to connect to a server.
‚Ä¢ send()/recv(): Send and receive data.
‚Ä¢ close(): Close the socket.

TCP Client Steps:
1. Create socket using socket().
2. Connect to the server using connect().
3. Send data using send().
4. Receive data using recv().
5. Close the connection.

TCP Server Steps:
1. Create socket using socket().
2. Bind socket to IP address and port using bind().
3. Start listening for clients using listen().
4. Accept incoming connection using accept().
5. Exchange data using send() and recv().
6. Close socket when done.

------------------------------------------------------
6. TOOLS AND TECHNOLOGIES USED:
------------------------------------------------------
‚Ä¢ Language: C / C++ / Java (depending on implementation)
‚Ä¢ Operating System: Ubuntu / Windows
‚Ä¢ Library: socket, netinet/in.h, sys/socket.h (for C/C++)
‚Ä¢ Functions: socket(), bind(), connect(), send(), recv(), close()

------------------------------------------------------
7. OUTPUT / EXPECTED RESULT:
------------------------------------------------------
‚Ä¢ The TCP client and server exchange messages successfully (e.g., ‚ÄúHello from Server‚Äù, ‚ÄúHello from Client‚Äù).
‚Ä¢ The UDP client and server send and receive datagrams without establishing a connection.
‚Ä¢ Displays confirmation of message transmission and reception between the two systems.

------------------------------------------------------
8. OUTCOME:
------------------------------------------------------
‚Ä¢ Students learned to create client-server applications using sockets.
‚Ä¢ Understood the difference between TCP and UDP communication.
‚Ä¢ Gained practical skills to develop real-time network programs.

------------------------------------------------------
9. CONCEPTS USED:
------------------------------------------------------
‚Ä¢ Socket Programming
‚Ä¢ TCP and UDP Protocols
‚Ä¢ Client-Server Architecture
‚Ä¢ Connection Establishment and Data Transfer
‚Ä¢ Error Handling in Network Communication

------------------------------------------------------
10. CONCLUSION:
------------------------------------------------------
We successfully implemented socket programming using C/C++/Java.  
We understood how TCP provides reliable communication and how UDP allows fast, connectionless data transfer between client and server.

------------------------------------------------------
FREQUENTLY ASKED QUESTIONS:
------------------------------------------------------
1. What is client-server communication?
   ‚Üí It is a communication model where one device (client) requests data or service, and another device (server) responds to it.
2. What is socket programming? 
   ‚Üí It is a method to establish communication between processes using network sockets.
3. Explain TCP and UDP.
   ‚Üí TCP is reliable and connection-oriented; UDP is faster but connectionless and unreliable.
